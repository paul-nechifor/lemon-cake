# # LemonCake
#
# A programming language that combines the speed of Ruby, with the flexibility
# of x86-64 Assembly, and the consistency of Lisp.

# ## Operators
(= + (~ (reduce add $args)))
(= - (~ (reduce sub $args)))
(= * (~ (reduce mul $args)))
(= / (~ (reduce div $args)))
(= | (~ (reduce binor $args)))
(= & (~ (reduce binand $args)))
(= join (~ (reduce join-lists $args)))
(= < (~ (reduce lt $args)))
(= <= (~ (reduce lte $args)))
(= > (~ (reduce gt $args)))
(= >= (~ (reduce gte $args)))

# ## Builtin functions

# ### min
(= min (~ (reduce (~ (a b) (if (< a b) a b)) $args)))

# ### max
(= max (~ (reduce (~ (a b) (if (> a b) a b)) $args)))

# ### identity
(= identity (~ (x) x))

# ### partial
#
# Creates a partial function.
#
# Example:
#
# > (= f (partial + 1 2))
# > (f 4 1)
# > > 8
#
# Which is the same as running:
#
# > (+ 1 2 4 1)
# > 8
(= partial (~ (fn) (last
  (= args (tail $args))
  (~ (apply fn (join args $args)))
)))

# ### tie
#
# Joins strings using a separator.
#
# Example:
#
# > (tie '_' :('a' 'b' 'c'))
# > >'a_b_c'
(= tie (~ (str xs)
  (apply cat (tail (apply join (map xs
    (~ (x) (list str x))
  ))))
))

# ### repeat
#
# Creates a list contaning `n` repetitions of a given value.
#
# Example:
#
# > (repeat 'a' 3)
# > > ('a' 'a' 'a')
(= repeat (~ (x n) (map (range n) (~ x))))

# ### at
#
# Get the value from a list that's at zero-based index `i`.
#
# Example:
#
# > (at :(1 2 3) 2)
# > 3
(= at (~ (l i) (head ((apply comp (repeat tail i)) l))))

# ### comp
#
# Generates a function that composes multiple functions that only accept one
# argument.
#
# So given functions `f`, `g`, `h`, these two lines are equivalent:
#
# > (~ (x) (f (g (h x))))
# > (comp h g f)
#
# Note that the functions are applied in the order in which they are given.
#
# TODO Fix the order.
#
# Example:
#
# > (= plus1 (~ (x) (+ x 1)))
# > (= double (~ (x) (list x x)))
# > (= fn (comp plus1 double double))
# > (fn 2)
# > > ((3 3) (3 3))
(= comp (~ (eval
  (list :~ :(x) (join
    :(last)
    (map $args (~ (fn)
      (list := :x (list fn :x))
    ))
    :(x)
  ))
)))

# ### list-dict
(= list-dict (~ (xs) (last
  (= ret (dict))
  (map xs (~ (x i) (set ret i x)))
  ret
)))

# ### zip
(= zip (~ (last
  (= lists (map $args list-dict))
  (= n-args (len lists))
  (= min-len (apply min (map lists len)))
  (map (range min-len) (~ (i) (map
    lists (~ (d) (get d i))
  )))
)))

# ## Util functions

# ### doc-code
(= doc-code (~ (input output) (last
  (= encode (~ (d) (last
    (apply cat (map
      (split '' d)
      (~ (x) (if (is x '<') '&lt;' (is x '>') '&gt;' x))
    ))
  )))

  (= process-comment (~ (c) (last
    (= surround (~ (tag chars)
      (cat '<' tag '>' (encode (apply cat (tail (tail chars)))) '</' tag '>')
    ))
    (= lines (split '\n' c))
    (= lines (map lines (~ (line) (last
      (= chars (split '' line))
      (if
        (is (len line) 0)
        '<p>'

        (is (at chars 0) '>')
        (surround 'pre' chars)

        (is (at chars 0) '#')
        (if
          (is (at chars 1) '#')
          (if
            (is (at chars 2) '#')
            (surround 'h3' (tail (tail chars)))
            (surround 'h2' (tail chars))
          )
          (surround 'h1' chars)
        )

        (encode line)
      )
    ))))
    (tie '\n' lines)
  )))

  (= split-parts (~ (str) (last
    (= left (dict 0 ''))
    (= right (dict))
    (= n 0)
    (= prev-is-left 1)
    (= clean (~ (cs) (last
      (= cs2 (tail cs))
      (apply cat (if (len cs2) (tail cs2) cs2))
    )))

    (map (split '\n' str) (~ (l) (last
      (= lsplit (split '' l))
      (= is-left (is (at lsplit 0) '#'))
      (if is-left
        (if prev-is-left
          (set left n (cat (get left n) '\n' (clean lsplit)))
          (last
            (= n (+ n 1))
            (set left n (clean lsplit))
          )
        )
        (if prev-is-left
          (set right n l)
          (set right n (cat (get right n) '\n' l))
        )
      )
      (= prev-is-left is-left)
    )))

    (cat
      '<div class="doc">'
      (apply cat (map (range (+ n 1)) (~ (i) (cat
        '<div class="sect">'
          '<div class="part left"><div class="text">'
            (process-comment (get left i))
          '</div></div>'
          '<div class="part right"><div class="code">'
            (encode (get right i))
          '</div></div>'
        '</div>'
      ))))
      '</div>'
    )
  )))

  (fs-write output (cat
    '<!doctype html>'
    '<html>'
      '<head>'
        '<title>LemonCake</title>'
        '<style>'
          'div{box-sizing:border-box}'
          'body{'
            'margin:0;'
            'background:linear-gradient('
              'to right,#fff 0%,#fff 50%,#f4f4f4 50%,#f4f4f4 100%'
            ')'
          '}'
          '.sect{clear:both}'
          '.part{width:50%;padding-top:50px}'
          '.left{float:left}'
          '.right{float:right;background:#f4f4f4}'
          'pre{background:#f4f4f4;margin:0;padding:6px 10px}'
          'pre+pre{padding-top:0}'
          '.text{'
            'width:100%;'
            'max-width:600px;'
            'padding-right:10px;'
            'float:right;'
            'font-family:sans-serif'
          '}'
          'h1,h2,h3{margin:0}'
          '.code{padding-left:10px;font-family:monospace;white-space:pre}'
        '</style>'
      '</head>'
      '<body>'
        (split-parts (fs-read input))
      '</body>'
    '</html>'
  ))
)))

# ## Assembler functions

(= reg0 (dict
  'al' 0
  'cl' 1
  'dl' 2
  'bl' 3
  'ah' 4
  'ch' 5
  'dh' 6
  'bh' 7
))

(= asm-instr (dict
  'add' (~ (a b) (if

    (and (in a reg0) (in b reg0))
    (list 0x00 (| 0xc0 (<< (get reg0 b) 3) (get reg0 a) ))

  ))
))
