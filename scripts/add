#!/usr/bin/env python2

import re
from itertools import product
from os import remove
from os.path import join, dirname
from subprocess import check_output

registers = zip(*[
    ['al', 'ax', 'eax', 'rax'],
    ['cl', 'cx', 'ecx', 'rcx'],
    ['dl', 'dx', 'edx', 'rdx'],
    ['bl', 'bx', 'ebx', 'rbx'],
    ['ah', 'sp', 'esp', 'rsp'],
    ['ch', 'bp', 'ebp', 'rbp'],
    ['dh', 'si', 'esi', 'rsi'],
    ['bh', 'di', 'edi', 'rdi'],
    ['r8b', 'r8w', 'r8d', 'r8'],
    ['r9b', 'r9w', 'r9d', 'r9'],
    ['r10b', 'r10w', 'r10d', 'r10'],
    ['r11b', 'r11w', 'r11d', 'r11'],
    ['r12b', 'r12w', 'r12d', 'r12'],
    ['r13b', 'r13w', 'r13d', 'r13'],
    ['r14b', 'r14w', 'r14d', 'r14'],
    ['r15b', 'r15w', 'r15d', 'r15'],
])

incompatible = set(registers[0][4:])


def main():
    for x in get_encoding(instructions()):
        print x


def instructions():
    for regs in registers:
        for a, b in product(regs, repeat=2):
            if a in incompatible and b in incompatible:
                continue
            yield 'add %s,%s' % (a, b)
    for a, b in product(registers[3], repeat=2):
        yield 'add [%s],%s' % (a, b)
        yield 'add %s,[%s]' % (a, b)
    regs1 = [x for x in registers[2] + registers[3] if x[-1] != 'h']
    regs2 = [x for x in sum(registers, ()) if x[-1] != 'h']
    for a, b in product(regs1, regs2):
        yield 'add [%s],%s' % (a, b)
        yield 'add %s,[%s]' % (b, a)
        yield 'add [%s+1],%s' % (a, b)
        yield 'add [%s+127],%s' % (a, b)
        yield 'add [%s+128],%s' % (a, b)


def get_encoding(instr):
    instr_str = 'BITS 64\n' + '\n'.join(instr)
    asm = join(dirname(__file__), '..', 'a.asm')
    elf = join(dirname(__file__), '..', 'a.out')
    open(asm, 'w').write(instr_str)
    check_output(['nasm', '-f', 'bin', '-o', elf, asm])
    output = check_output([
        'objdump', '-D', '-Mintel,x86-64', '-bbinary', '-mi386', elf
    ])
    remove(asm)
    remove(elf)
    out = process_output(output.split('\n')[7:-1])
    for x in out:
        print x[1].ljust(30), x[0]


def process_output(lines):
    ret = []

    for line in lines:
        parts = line.split('\t')[1:]
        if len(parts) == 1:
            ret[-1][0] = ret[-1][0] + ' ' + parts[0].strip()
            continue
        ret.append([
            parts[0].strip(),
            re.sub(r'\s+', ' ', re.sub('([DQ]?WORD|BYTE) PTR ', '', parts[1])),
        ])

    return ret


if __name__ == '__main__':
    main()
